\documentclass[12pt, letterpaper]{article}
\usepackage{tikz}
\usepackage{tkz-euclide}
\usetikzlibrary{positioning}
\usepackage{fancybox}
\usepackage{texlogos}
\usepackage{graphicx}
\usepackage{flafter} % needed for figures
\usepackage{hyperref} % needed for a clickable table of contents
\usepackage[export]{adjustbox} % needed for adjustable images
\usepackage{polyglossia} % needed for catalan support
\setmainlanguage{catalan}
\usepackage{listings}
\usepackage{appendix}
\graphicspath{ {images/} }

% centered box
\makeatletter
\newenvironment{CenteredBox}{% 
\begin{Sbox}}{% Save the content in a box
\end{Sbox}\centerline{\parbox{\wd\@Sbox}{\TheSbox}}}% And output it centered
\makeatother

% rename for quotes
\let\oldquote\quote
\let\endoldquote\endquote
\renewenvironment{quote}[2][]
  {\if\relax\detokenize{#1}\relax
     \def\quoteauthor{#2}%
   \else
     \def\quoteauthor{#2~---~#1}%
   \fi
   \oldquote}
  {\par\nobreak\smallskip\hfill(\quoteauthor)%
   \endoldquote\addvspace{\bigskipamount}}

% for appendix
\makeatletter
\newcommand\appendix@section[1]{%
  \refstepcounter{section}%
  \orig@section*{Apèndix \@Alph\c@section: #1}%
  \addcontentsline{toc}{section}{Apèndix \@Alph\c@section: #1}%
}
\let\orig@section\section
\g@addto@macro\appendix{\let\section\appendix@section}
\makeatother

% information
\title{\textbf{Pràctica 1 || Aquæductus}}
\author{Pablo Fraile Alonso}
\date{\today}

% document
\begin{document}
% title
\maketitle
\thispagestyle{empty}
\newpage
\tableofcontents
\listoffigures
\newpage

% begin contents
\section{Funcionament algorisme}

% backtracking
\subsection{Primera idea: Backtracking}

\subsubsection{Per què no utilitzar Backtracking en aquest cas}
cost de $O(n!)$ .

% principi optimitat
\newpage
\subsection{Alternativa a backtracking: Principi d'optimitat}
Abans de poder comentar la solució, hem d'entendre que és el principi d'optimitat: 
\begin{quote}{Richard E.Bellman} Principi d'optimitat: Una política òptima té la propietat que sigui quin sigui l'estat inicial i la decisió inicial, les decisions restants han de construir una política òptima respecte a l'estat resultat de la primera decisió.
\end{quote}

Per tant, seguint aquesta definició podem dir que un problema podrà ser resolt seguint el principi d'optimitat si la seva solució òptima pot ser construïda eficientment a partir de les solucions òptimes dels seus subproblemes. En altres paraules, que podem resoldre un problema gran donades les solucions dels seus problemes petits.

% nostre cas d'us
\subsubsection{Aplicació i funcionament en el nostre cas d'ús}
\label{seccio:funcionament}
En el nostre problema dels aqüeductes, veiem que podem aplicar el principi d'optimitat per a trobar una solució òptima, ja que la solució és construïda eficientment a partir de les solucions òptimes dels seus subproblemes. Per a explicar-ho millor he decidit resoldre un petit exemple.


Donada la següent entrada: 


\begin{center}
\begin{figure}[htbp]
\begin{CenteredBox}
\begin{lstlisting}[language={}]
5 6 180 20
0 0
2 2
3 1
5 3
7 2
\end{lstlisting}
\end{CenteredBox}
\caption{Entrada exemple}
\label{demostracio:entradaexemple}
\end{figure}
\end{center}


On podem veure que tenim 5 punts, una altura d'aqüeducte de 6, $\alpha$ = 180 i $\beta$ = 20. Si ho representem en un eix de coordenades, el perfil del sòl ens queda com la figura \ref{grafic:exemplecoordenades}, en canvi, si ho volem examinar en forma de dígraf (ja descartant opcions que no són vàlides) ens queda com a resultat la figura \ref{grafic:digraf}\\


\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}
   \tkzInit[xmax=7,ymax=6,xmin=0,ymin=0]
   \tkzGrid
   \tkzAxeXY
   \draw[thick] (0,0) -- (2, 2); 
   \draw[thick] (2,2) -- (3, 1); 
   \draw[thick] (3,1) -- (5, 3); 
   \draw[thick] (5,3) -- (7, 2); 
   \draw[thick, red] (0,6) -- (7, 6) node[midway, above] {height (6)}; 
    \foreach \Point/\PointLabel in {(0,0)/A, (2,2)/B, (3,1)/C, (5,3)/D, (7,2)/E}
   \draw[fill=black] \Point circle (0.05) node[above] {$\PointLabel$};
  \end{tikzpicture}
\caption{Exemple representat eix de coordenades}
\label{grafic:exemplecoordenades}
\end{center}
\end{figure}

\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}[roundnode/.style={circle, draw=black!60, very thick, minimum size=7mm},]
    % nodes
    \node[roundnode]      (A)                              {A};
    \node[roundnode]      (B)       [right=2cm of A]       {B};
    \node[roundnode]      (C)       [right=2cm of B]       {C};
    \node[roundnode]      (D)       [right=2cm of C]       {D};
    \node[roundnode]      (E)       [right=2cm of D]       {E};
    % lines
    \draw[->] (A.east) -- (B.west);
    \draw[->] (A.east) to[out=20,in=130] (C);
    \draw[->] (A.east) to[out=50,in=140] (D);
    \draw[->] (A.east) to[out=80,in=160] (E);
    \draw[->] (B.east) -- (C.west);
    \draw[->] (B.east) to[out=-20,in=-130] (D);
    \draw[->] (B.east) to[out=-50,in=-140] (E);
    \draw[->] (C.east) -- (D.west);
    \draw[->] (C.east) to[out=-20,in=-130] (E.west);
    \draw[->] (D.east) -- (E.west);
\end{tikzpicture}
\caption{Exemple representat en forma de dígraf}
\label{grafic:digraf}
\end{center}
\end{figure}

A continuació, anomenarem la funció $f(x)$ com el mínim cost per anar al node E. En el cas d'estar al propi node E, aquesta funció retornarà 0 (figura \ref{resultat:fdeE}).\\

\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}[roundnode/.style={circle, draw=black!60, very thick, minimum size=7mm},
                    donenode/.style={circle, draw=green!60, fill=green!5, very thick, minimum size=7mm},]
    % nodes
    \node[roundnode]      (A)                              {A};
    \node[roundnode]      (B)       [right=2cm of A]       {B};
    \node[roundnode]      (C)       [right=2cm of B]       {C};
    \node[roundnode]      (D)       [right=2cm of C]       {D};
    \node[donenode]      (E)       [right=2cm of D, label=below:$f(E)$ -> 0]       {E};
    % lines
    \draw[->] (A.east) -- (B.west);
    \draw[->] (A.east) to[out=20,in=130] (C);
    \draw[->] (A.east) to[out=50,in=140] (D);
    \draw[->] (A.east) to[out=80,in=160] (E);
    \draw[->] (B.east) -- (C.west);
    \draw[->] (B.east) to[out=-20,in=-130] (D);
    \draw[->] (B.east) to[out=-50,in=-140] (E);
    \draw[->] (C.east) -- (D.west);
    \draw[->] (C.east) to[out=-20,in=-130] (E.west);
    \draw[->] (D.east) -- (E.west);
\end{tikzpicture}
    \caption{resultat de $f(E)$}
\label{resultat:fdeE}
\end{center}
\end{figure}


En el cas de $f(D)$, únicament té una opció possible, anar del node D a F, per tant el cost mínim serà el recorregut mostrat a la figura \ref{resultat:fdeD} i la funció retornarà el valor del cost de crear un pilar a D, més el cost de crear un pilar a F i el cost de crear el arc de D a F.\\


\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}[roundnode/.style={circle, draw=black!60, very thick, minimum size=7mm},
                    donenode/.style={circle, draw=green!60, fill=green!5, very thick, minimum size=7mm},]
    % nodes
    \node[roundnode]      (A)                              {A};
    \node[roundnode]      (B)       [right=2cm of A]       {B};
    \node[roundnode]      (C)       [right=2cm of B]       {C};
    \node[donenode]      (D)       [right=2cm of C, label=below:$f(D)$ -> 1340]       {D};
    \node[donenode]      (E)       [right=2cm of D, label=below:$f(E)$ -> 0]       {E};
    % lines
    \draw[->] (A.east) -- (B.west);
    \draw[->] (A.east) to[out=20,in=130] (C);
    \draw[->] (A.east) to[out=50,in=140] (D);
    \draw[->] (A.east) to[out=80,in=160] (E);
    \draw[->] (B.east) -- (C.west);
    \draw[->] (B.east) to[out=-20,in=-130] (D);
    \draw[->] (B.east) to[out=-50,in=-140] (E);
    \draw[->] (C.east) -- (D.west);
    \draw[->] (C.east) to[out=-20,in=-130] (E.west);
    \draw[->, green] (D.east) -- (E.west);
\end{tikzpicture}
    \caption{resultat de $f(D)$}
\label{resultat:fdeD}
\end{center}
\end{figure}


En el cas de $f(C)$, té l'opció d'anar a D o d'anar a E. En aquest cas calcularem el cost de C a E i el cost de C a D + $f(D)$ i agafarem el mínim. Calculem cost de C a E i ens dona 1940, en canvi, el cost de C a D + $f(D)$ ens dona 2320. Per tant, el cost mínim des de C serà anant de C a E (figura \ref{resultat:fdeC}).\\

\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}[roundnode/.style={circle, draw=black!60, very thick, minimum size=7mm},
                    donenode/.style={circle, draw=green!60, fill=green!5, very thick, minimum size=7mm},]
    % nodes
    \node[roundnode]      (A)                              {A};
    \node[roundnode]      (B)       [right=2cm of A]       {B};
    \node[donenode]      (C)       [right=2cm of B, label=below:$f(C)$ -> 1940]       {C};
    \node[donenode]      (D)       [right=2cm of C, label=below:$f(D)$ -> 1340]       {D};
    \node[donenode]      (E)       [right=2cm of D, label=below:$f(E)$ -> 0]       {E};
    % lines
    \draw[->] (A.east) -- (B.west);
    \draw[->] (A.east) to[out=20,in=130] (C);
    \draw[->] (A.east) to[out=50,in=140] (D);
    \draw[->] (A.east) to[out=80,in=160] (E);
    \draw[->] (B.east) -- (C.west);
    \draw[->] (B.east) to[out=-20,in=-130] (D);
    \draw[->] (B.east) to[out=-50,in=-140] (E);
    \draw[->, green] (C.east) to[out=-20,in=-130] (E.west);
    \draw[->, green] (D.east) -- (E.west);
\end{tikzpicture}
    \caption{resultat de $f(C)$}
\label{resultat:fdeC}
\end{center}
\end{figure}

En el cas de $f(B)$, farem el mateix que amb $f(C)$. Calcularem quant val el cost de B a E, de B a C + $f(C)$ i de B a D + $f(D)$ i agafarem el mínim. En aquest cas el mínim es de B a E (1940) (figura \ref{resultat:fdeB}).\\

\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}[roundnode/.style={circle, draw=black!60, very thick, minimum size=7mm},
                    donenode/.style={circle, draw=green!60, fill=green!5, very thick, minimum size=7mm},]
    % nodes
    \node[roundnode]      (A)                              {A};
    \node[donenode]      (B)       [right=2cm of A, label=below:$f(B)$ -> 1940]       {B};
    \node[donenode]      (C)       [right=2cm of B, label=below:$f(C)$ -> 1940]       {C};
    \node[donenode]      (D)       [right=2cm of C, label=below:$f(D)$ -> 1340]       {D};
    \node[donenode]      (E)       [right=2cm of D, label=below:$f(E)$ -> 0]       {E};
    % lines
    \draw[->] (A.east) -- (B.west);
    \draw[->] (A.east) to[out=20,in=130] (C);
    \draw[->] (A.east) to[out=50,in=140] (D);
    \draw[->] (A.east) to[out=80,in=160] (E);
    \draw[->, green] (B.east) to[out=-50,in=-140] (E);
    \draw[->, green] (C.east) to[out=-20,in=-130] (E.west);
    \draw[->, green] (D.east) -- (E.west);
\end{tikzpicture}
    \caption{resultat de $f(B)$}
\label{resultat:fdeB}
\end{center}
\end{figure}


Finalment, en el cas de $f(A)$, haurem de calcular el cost de A a E, de A a B + $f(B)$, de A a C + $f(C)$ i de A a D + $f(D)$ i agafar el mínim cost. En aquest cas el mínim es de A a E (2780) (figura \ref{resultat:final})


\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}[roundnode/.style={circle, draw=black!60, very thick, minimum size=7mm},
                    donenode/.style={circle, draw=green!60, fill=green!5, very thick, minimum size=7mm},]
    % nodes
    \node[donenode]      (A)       [label=below:\textbf{$f(A)$ -> 2780}]                       {A};
    \node[donenode]      (B)       [right=2cm of A, label=below:$f(B)$ -> 1940]       {B};
    \node[donenode]      (C)       [right=2cm of B, label=below:$f(C)$ -> 1940]       {C};
    \node[donenode]      (D)       [right=2cm of C, label=below:$f(D)$ -> 1340]       {D};
    \node[donenode]      (E)       [right=2cm of D, label=below:$f(E)$ -> 0]          {E};
    % lines
    \draw[->, green] (A.east) to[out=20,in=160] (E);
    \draw[->, green] (B.east) to[out=-50,in=-140] (E);
    \draw[->, green] (C.east) to[out=-50,in=-130] (E.west);
    \draw[->, green] (D.east) -- (E.west);
\end{tikzpicture}
    \caption{resultat del aqüeducte mínim ($f(A)$)}
\label{resultat:final}
\end{center}
\end{figure}

% demostració algorisme
\newpage
\subsubsection{Demostració per reducció al absurd}
Donat un aqüeducte que va d'un punt A a un punt J i del qual sabem que el recorregut R\textsubscript{a...j} és l'òptim (figura: \ref{demostracio:atoj}).

\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}[roundnode/.style={circle, draw=green!60, fill=green!5, very thick, minimum size=7mm},]
    % nodes
    \node[roundnode]      (A)                                  {A};
    \node[roundnode]      (J)       [right=3cm of A]           {J};
    % lines
    \draw[->] (A.east) -- (J.west) node[midway, below] {R\textsubscript{a...j}};
\end{tikzpicture}
\caption{Aqüeducte de punt A a punt J}
\label{demostracio:atoj}
\end{center}
\end{figure}

Assumirem també que aquest recorregut passa per el punt K, per tant ara podem separar el recorregut com R\textsubscript{a...k} \& R\textsubscript{k...j} (figura \ref{demostracio:atoktoj})

\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}[roundnode/.style={circle, draw=green!60, fill=green!5, very thick, minimum size=7mm},]
    % nodes
    \node[roundnode]      (A)                              {A};
    \node[roundnode]      (K)        [right=3cm of A]      {K};
    \node[roundnode]      (J)        [right=3cm of K]      {J};
    % lines
    \draw[->] (A.east) -- (K.west) node[midway, below]{R\textsubscript{a...k}};
    \draw[->] (K.east) -- (J.west) node[midway, below]{R\textsubscript{k...j}};
\end{tikzpicture}
\caption{Aqüeducte de punt A a punt J passant per K}
\label{demostracio:atoktoj}
\end{center}
\end{figure}

Ara donarem com a hipòtesis que del punt A al punt K pot haver-hi un recorregut mes òptim, que anomenarem R'\textsubscript{a...k} (figura \ref{demostracio:atoktojhypotetical}).

\begin{figure}[htbp]
\begin{center}
\begin{tikzpicture}[roundnode/.style={circle, draw=green!60, fill=green!5, very thick, minimum size=7mm},]
    % nodes
    \node[roundnode]      (A)                              {A};
    \node[roundnode]      (K)        [right=3cm of A]      {K};
    \node[roundnode]      (J)        [right=3cm of K]      {J};
    % lines
    \draw[->] (A.east) -- (K.west) node[midway, below]{R\textsubscript{a...k}};
    \draw[->] (K.east) -- (J.west) node[midway, below]{R\textsubscript{k...j}};
    \draw[->, red] (A) to[out=-70,in=-100] (K) node[xshift =- 2cm, yshift =-1.8cm]{R'\textsubscript{a...k}};
\end{tikzpicture}
\caption{Graf que representa un possible R'\textsubscript{a...k}}
\label{demostracio:atoktojhypotetical}
\end{center}
\end{figure}

Si R'\textsubscript{a...k} és més òptim que R\textsubscript{a...k}, llavors vol dir que: \\
\begin{center}
R'\textsubscript{a...k} < R\textsubscript{a...k}.\\
\end{center}
Llavors:\\
\begin{center}
\textbf{R'\textsubscript{a...k} + R\textsubscript{k...j} < R\textsubscript{a...k} + R\textsubscript{k...j}} \\
\end{center}

Però aquesta afirmació \textbf{NO} pot ser certa! Ja que en un principi hem assegurat que R\textsubscript{a...k} + R\textsubscript{k...j} era la solució òptima i per tant no hi pot haver-hi cap més petita que aquesta.


\subsubsection{Especificació formal}
Un cop ja sabem el funcionament del algorisme i hem demostrat que el seu comportament es correcte, podem especificar-lo amb una formula molt similar a la de l'equació de Bellman (ja que tal i com s'ha dit a la subsecció \ref{seccio:funcionament} aquest problema es resolt seguint el principi d'optimitat).

\begin{center}
\begin{equation}
v(x_{0}) = min(f(x_{0}) + v(x_{1}))
\end{equation}
On $v(x)$ és la fórmula per a calcular el cost mínim del aqüeducte, $x_{0}$ es el primer pilar del aqüeducte i $x_{1}$ es el resultat d'aplicar $v(x)$ al pilar que va desprès de $x_{0}$
\end{center}

\section{Cost algorisme}
\subsection{Iteratiu}
$O(n^{3})$ 
\subsection{Recursiu}
$O(n^{3})$ 
    
\section{Problemes/consideracions}
\subsection{Nombres en \cpluspluslogo}
Primerament es va pensar i elaborar l'algorisme en el llenguatge de programació python, i a continuació es va migrar el codi a \cpluspluslogo. El problema va estar en no es va pensar que python al tindre tipus dinàmics el mateix intèrpret assigna un tipus a cada variable de forma intel·ligent, mentres que a \cpluspluslogo el propi programador és el que assigna els tipus. Això va generar un problema ja que, com els tests eren summament grans i podien arribar a fer operacions com per exemple $10000^{2}$, feia que no fos suficient amb els tipus integer, i s'hagués d'utilitzar tipus com per exemple ``long long int" o ``unsigned long long int".

\section{Conclusions}

\appendix
\section{Pseudocodi algorisme iteratiu}
\label{pseudocodiiteratiu}

\section{Pseudocodi algorisme recursiu}
\label{pseudocodirecursiu}

\end{document}
